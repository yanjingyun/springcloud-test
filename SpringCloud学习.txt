
集中式系统和分布式系统:
	-1）集中式系统：一个主机带多个终端（如浏览器），终端没有数据处理能力，仅负责数据的录入和输出，而运算、存储等全部在主机上运行。
	-2）分布式系统：把一个计算任务分解为若干个计算单元，并分派到若干个不同的计算机中去执行，然后再汇总计算结果。
	附：终端（terminal），也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入及处理结果的输出等。

分布式和集群的区别：
	-1）分布式（distributed）：指多台不同的服务器中部署不同的服务模块，通过远程调用RPC协同工作，对外提供服务
	-2）集群（cluster）：指在多台不同的服务器中部署相同的应用或服务模块，构成一个集群，通过负载均衡设备对外提供服务。

spring、springboot、SpringCloud关系？
	1、Spring两大核心功能IOC和AOP。
	2、springboot在spring生态基础上发展而来，它的出现是为了更容易的使用Spring。
	3、springCloud是一系列框架的有序集合。它利用Springboot的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Springboot的开发风格做到一键启动和部署。

SpringCloud与dubbo相比：
	dubbo专注于RPC框架，其它的分布式技术需要依赖第三方技术来组装出一个分布式架构。现已弃用。
	springCloud是一站式服务，提供了所有分布式架构需要的技术，不用依赖其它第三方技术，所以各组件间的兼容性很好。各服务间调用使用http协议。


概述：
	SpringCloud是基于SpringBoot的分布式微服务框架，为开发人员提供分布式服务的相关技术模块。如服务注册与发现(注册中心和服务提供者)、服务消费者(负载均衡)、熔断器、配置管理、消息总线、路由网关、服务追踪等。
微服务系统描述：
	客户端的请求首先通过负载均衡（zuul、nginx），再到达服务网关（zuul集群、SpringCloudGateway），然后再到具体的服务。
	服务统一注册到高可用的服务注册中心集群，服务的所有配置文件由配置服务管理，配置服务的配置文件放在git仓库。
相关技术：
	1、eureka：包括注册中心(eureka server)和服务提供者(eureka client)
		各服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
	2、ribbon+restTemplate 2、feign --服务消费者、服务与服务之间负载均衡
	3、Hystrix：熔断器
		测试：1、ribbon使用断路器hystrix 2、feign自带断路器 3、监控工具Hystrix-Dashboard
	4、Config：配置中心。配置文件统一管理。
	5、Zuul/gateway：路由转发和过滤器、网关。
		若前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务
		zuul默认和Ribbon结合实现了负载均衡的功能。
		比如／api/user转发到到user服务，/api/shop转发到到shop服务。


分布式微服务:SpringCLoud、Dubbo
服务注册发现：Eureka、consul、zk、nacos
配置中心：SpringConfig、nacos、携程apoll
链路追踪：sleuth
eureka：注册中心
zuul：网关
ribbon：负载均衡
feign：服务调用
hystix：熔断器


配置方案：
	1、将整个系统按业务拆分成若干子系统或微服务，且每个子系统可部署多个应用，多个应用间使用负载均衡。
	2、需要一个注册中心(Eureka Server)，所有服务都将注册到注册中心。注册中心可部署多个，以保证高可用。
	3、所有服务(EurekaClient)都统一注册到注册中心，服务之间采用feign/feign进行调用。每个服务可配置多个，调用同一服务可按照一定策略来实现负载均衡。
	3、所有客户端都通过统一网地址访问后台的服务，通过路由配置zuul或gwteway网关来判断一个url请求由哪个服务处理。请求转发到服务上的时候使用负载均衡Ribbon/feign。
	5、使用断路器 hystrix，及时处理服务调用时的超时和错误，防止由于其中一个服务的问题而导致整体系统的瘫痪。
	6、还需要一个监控功能，监控每个服务调用花费的时间等。
	7、使用 SpringCloud Config 进行统一的配置管理，对所有服务的配置资源统一管理。
	8、Hystrix，监控和断路器。我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能。
	9、Hystrix Dashboard，监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。
	10、Turbine，监控聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而Turbine可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看。




服务注册与发现(Eureka)：
	1、Eureka是一个服务注册和发现模块。
	2、Eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可用在内存中完成），默认情况下eureka server也是一个eureka client，必须要指定一个server。
	3、在短时间内大量微服务没有心跳服务，会开启保护模式，不会立即删除注册表中没有心跳的微服务。当心跳回到阈值时会自动关闭保护模式。
	4、每个服务单元向注册中心登记自己提供的服务，将主机、端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。

	Eureka服务端，服务注册中心。
	1）服务注册中心：
		所有微服务集群都可以是它的客户端，来注册和订阅。
		启动一个springBoot应用，需要依赖spring-cloud-starter-eureka-server组件，无需编写其它代码。并将主启动类标识@EnableEurekaServer。在yml配置文件中配置自己的访问地址等信息。
	2）服务注册：
		启动一个springBoot应用，需要依赖spring-cloud-starter-eureka和spring-cloud-starter-config组件。并将主启动类标识@EnableEurekaClient。在yml配置文件中指定注册中心的访问地址等信息。这样本服务启动后会自动注册进eureka服务注册中心中。
	3）服务发现：
		@EnableDiscoveryClient 本应用的主启动类上添加此注解表示：服务发现。进而可以在所有bean中使用DiscoveryClient接口来访问Eureka.或结合RestTemplate来访问Restful风格的http服务。
	4）Eureka集群：
		各Eureka相互知晓。每个客户端要知晓所有Eureka，类似RocketMQ的NameServer。
	5）与Zookeeper比较：
		有自我保护机制。没有主从概念。
		Zookeeper出现网络故障时会花30-120s来选举新master,而导致注册中心不可用，可用性不好。

服务与服务之间通讯：
	基于http restful的。
	spring cloud有两种调用方式：1）ribbon+restTemplate 2）feign

Eureka注册中心、服务提供者、服务消费者：
	1、注册中心(eureka server)：在启动类上添加@EnableEurekaServer注解，表明自己是一个eurekaServer。
	2、服务提供者(eureka client)：当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。服务注册中心从每个client实例接收心跳消息。如果心跳超时，则通常将该实例从注册server中删除。
	3、服务消费者(ribbon/feign)：
		在微服务架构中，业务都会拆分成一个独立的服务，服务与服务的通讯是基于http restful的。
		Spring Cloud有两种服务调用方式：1）ribbon+restTemplate，2）feign。
		ribbon是一个负载均衡客户端，可以很好的控制http和tcp的一些行为。Feign默认集成了ribbon。

负载均衡（Ribbon、Feign）
	将用户请求平摊分配到多个服务。
	负载均衡分两种：
		集中式：在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如Nginx、LVS),由该设施负责把请求通过某种策略转发至服务的提供方。
		进程内：将LB逻辑集成到消费方（如dubbo、Ribbon），消费方从服务注册中心获知有哪些地址可用，然后自己从这些地址中选择出一个合适的服务器
	1）Ribbon：
		构建过程：依赖eureka
		客户端首先引入eureka客户端组件，再从restTemplate的bean上加上@LoadBalanced注解，就可以用微服务的名称从eureka集群中获取服务列表，进而选出一台服务器。
		核心组件：IRule根据特定算法从服务列表中选取一个要访问的服务。自带7种均衡策略。默认轮询。
		修改默认策略：向容器中注册一个IRule的bean，这样ribbon就会使用用户自己的策略来覆盖默认策略。
		自定义策略：
			在主启动类上加@RibbonClient(name="服务名", configuration=XxxRuler.class)，从而在启动服务的时候就能去加载自定义的Ribbon配置类。
			代码中向容器注入自己的XxxRuler的bean.
	2）feign描述：
		feign是一个声明式的伪http客户端。feign采用的是基于接口注解。
		Feign 整合了ribbon，并和eureka结合，默认实现了负载均衡的效果。
		整合了Hystrix，具有熔断的能力


短路器（Hystrix）
	在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。
	
	功能：服务降级、服务熔断、服务限流、接近实时的监控。
	
服务端服务熔断
1.概念：
	一般指某个服务的下游服务出现问题时采用的手段,而服务降级一般是从整体层面考虑的。下游服务出现问题时可以进行服务熔断。
	对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞的。再等到目标服务好转后进行接口恢复。
2.实现步骤：
	1）主启动类添加@EnableCircuitBreaker注解。
	2）在@RequestMapping处增加@HystrixCommand（fallbackMethod="方法名"），新建一个出入参相同的类似方法，以便在原方法抛出异常时代替原方法。
	3）默认每次原方法抛出异常都会触发熔断。
	
客户端服务降级
1.概念：
	整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再开启回来。它依赖Feign。
	当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
2.实现步骤：
		1）新建一个FallbackFactory接口的实现类，重写create方法。
		2）在@FeignClient注解中加fallbackFactory属性值。例如：@FeignClient(value="", fallbackFactory=xxxFallbackFactory.class)
		3）开启Feign对Hystrix的支持。在yml配置文件中配置feign.hystrix.enabled: true

Hystrix隔离、熔断和降级的全流程：
	1、Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。
	2、但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！
	3、积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。
限流：
	详情：https://www.fangzhipeng.com/springcloud/2018/12/22/sc-f-gatway4.html
常见限流方式：
	Hystrix使用线程池隔离，超过线程池的负载，走熔断的逻辑。
	一般应用服务器中，如tomcat容器也是通过限制它的线程数来控制并发的。
常见限流维度：
	ip限流、uri限流、用户访问频次限流
常见限流算法：
	1、计数器算法：可能存在“突刺现象”
	2、漏桶算法：准备一个队列保存请求，通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。问题：可能无法应对短时间的突发流量
	3、令牌桶算法：准备一个队列保存令牌，通过一个线程池定期生成令牌放队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。


路由网关（zuul/gateway）
	路由和过滤的作用。也是一个微服务集群，也需要注册到Eureka中。可以设置统一的访问入口。所有服务都可以通过它来间接访问。
	使用步骤：
		1）添加Eureka和Zuu的maven依赖。
		2）主启动类上添加@EnableZuulProxy注解，无需@EnableDiscoveryClient注解。
		3）配置Eureka的相关配置信息。
		4）使用http://路由网关的ip+port/要请求的微服务名称/原微服务访问地址
		5）还可以将“微服务名称”进行映射。
Zuul：
	人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？
	所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。
	有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。



配置中心（Config）
	它是一个类似于Eureka的服务，有服务端和客户端。每个微服务作为客户端，spring-config作为服务端，它来监控远程配置中心的配置文件是否发生变化。
	远程配置中心默认采用git来存储配置信息，这样有助于对环境配置进行版本管理，并可以通过git客户端工具来方便的管理和访问配置内容。
	使用步骤：
		1）在gitHub上建立一个仓库。
		2）创建一个微服务，主启动类上添加@EnableConfigServer注解。


分布式锁：
	分布式锁（全局锁）实现：基于redis实现、基于Zookeeper实现、基于Consul实现
	--实例：基于Concul的分布式锁
	基于Consul的分布式锁主要利用key/value存储API中的acquire和release操作来实现。
	acquire操作：当锁不存在持有者时返回true，并且设值setValue，同时执行操作的session会持有对该key的锁，否则就返回false。
	release操作：使用指定session来释放某个key的锁，如果指定的session无效，则会返回false，否则就会设值setValue，并返回true。

RestTemplate：用于进行http请求


扛住阿里双十一高并发流量，Sentinel是怎么做到的？
	Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景
	名词解释：
		服务限流:当系统资源不够，不足以应对大量请求，对系统按照预设的规则进行流量限制或功能限制
		服务熔断:当调用目标服务的请求和调用大量超时或失败，服务调用方为避免造成长时间的阻塞造成影响其他服务，后续对该服务接口的调用不再经过进行请求，直接执行本地的默认方法
		服务降级:为了保证核心业务在大量请求下能正常运行，根据实际业务情况及流量，对部分服务降低优先级，有策略的不处理或用简单的方式处理
	服务降级的实现可以基于人工开关降级（秒杀、电商大促等）和自动检测（超时、失败次数、故障），熔断可以理解为一种服务故障降级处理


总结：
	Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
	Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
	Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
	Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
	Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务
